[
  {
    "title": "Basic Tasks Using a Jupyter Notebook with Code in Python for Analytical Chemistry Data Analysis",
    "description": "Generate code in Python to perform four basic tasks: Basic calculations; Entering data into NumPy arrays; Fitting data in NumPy arrays to a NumPy or SciPy nonlinear model function; Creating a Matplotlib graph of data in NumPy arrays and of a nonlinear model function.",
    "expanded_description": "This lesson can be used as an introduction to Analytical Chemistry Data Analysis tasks in Python.\nThe suggested context would be to walk through it together during the first week of Analytical Laboratory.\nAbout 45 minutes to an hour should be allocated to this lesson; an hour is best.\n",
    "programming_skill": "None",
    "primary_course": "Analytical Chemistry",
    "also_for": [
      "Instrumental Analysis",
      "Physical Chemistry"
    ],
    "authors": [
      "Dr. Christine Morales"
    ],
    "instructor_email": "moralech@mountunion.edu",
    "student_level": "Undergraduate - Second Year",
    "students_piloted": 10,
    "instructor_notes": "This introductory module works well as the first programming lesson for students with no coding experience.\n\nTeaching tips:\n- Students should work together in groups to ensure they are accountable to understand each part.\n- Encourage students to share ideas but code/answer questions in their own copy of the notebook.\n- Remind students to save their own copy before they begin work.\n- Some students may have several Google accounts; remind them to be aware of which account is logged in when they save.\n- Students are asked to copy/paste the **editable plain text**; Colab preview mode uses a different character set.\n- If you do not have a full hour available in lab, consider scheduling an out-of-class help session for the Major Challenge.\n- Please edit the last Markdown cell to reflect your own policies for turning in assignments.\n- If you accept links to student copies of Jupyter notebooks instead of the actual .ipynb files, students may change the file until you grade it.  If using nbgrader, you could set it up to run when the assignment is due.\n- If you require students to download their completed Jupyter notebooks, students should download the .ipynb file and turn it in.\n\nCommon student questions:\n- These files are called \"Juypter notebooks,\" but students may also have \"laboratory notebooks\" that need to be turned in separately.  Clarify which is which.\n- Students may ask which file format to download.  They should download the .ipynb file of their completed notebook.\n",
    "related_modules": [
      "calibration-of-glassware",
      "statistical-testing-beta",
      "solution-preparation-spectrophotometry",
      "standard-addition-spectophotometry",
      "ocean-acidification",
      "buffer-solutions",
      "hplc-analysis",
      "gc-ms-internal-standard"
    ],
    "estimated_time": "1 hour",
    "format": "Single Notebook",
    "materials": [
      {
        "title": "Basic Tasks using a Jupyter Notebook with Code in Python",
        "description": "This Jupyter notebook can be used to generate code in Python to perform four basic tasks: Basic calculations; Entering data into NumPy arrays; Fitting data in NumPy arrays to a NumPy or SciPy nonlinear model function; Creating a Matplotlib graph of data in NumPy arrays and of a nonlinear model function.",
        "type": "notebook",
        "duration": "1 hour",
        "github_url": "https://github.com/act-cms/moralech-umu-basic-tasks/blob/main/Basic_Tasks_Student_Version.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/moralech-umu-basic-tasks/blob/main/Basic_Tasks_Student_Version.ipynb",
        "objectives": [
          "Content: Recognize and report significant figures",
          "Content: Convert between mass in grams and amount in moles",
          "Content: Explain periodic trends in molar masses",
          "Process: Use Python code to define values and functions, and to perform calculations",
          "Process: Use Python code to report the output of calculations in a specified format",
          "Process: Use Python code to fit data to a model, and report the fitted model",
          "Process: Use Python code to plot data with a model, and display the plot in a specified format"
        ]
      }
    ],
    "scientific_objectives": [
      "Recognize and report significant figures",
      "Convert between mass in grams and amount in moles",
      "Explain periodic trends in molar masses"
    ],
    "cyberinfrastructure_objectives": [
      "Use Python code to define values and functions, and to perform calculations",
      "Use Python code to report the output of calculations in a specified format",
      "Use Python code to fit data to a model, and report the fitted model",
      "Use Python code to plot data with a model, and display the plot in a specified format"
    ],
    "scientific_prerequisites": [
      "Significant Figures",
      "Moles and Molar Masses",
      "Periodic Table"
    ],
    "programming_prerequisites": [
      "No prior programming experience required"
    ],
    "platforms": [
      "Google Colab"
    ],
    "recommended_platform": "Google Colab",
    "public_repo_url": "https://github.com/act-cms/moralech-umu-basic-tasks",
    "instructor_materials_url": "https://github.com/act-cms/instructor-materials/raw/main/moralech-umu-basic-tasks/Basic-Tasks.zip",
    "tags": [
      "python",
      "analytical-chemistry",
      "laboratory",
      "data-analysis"
    ],
    "id": "moralech-umu-basic-tasks",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "moralech-umu-basic-tasks"
  },
  {
    "title": "Bridging Basic Chemistry and Cheminformatics: A Jupyter-based Module on Molecular Representation for Introductory Chemistry",
    "description": "Students will learn how molecules are represented computationally and apply programming concepts to analyze and visualize molecular structures using Jupyter notebooks. The lesson builds foundational skills in cheminformatics and computational thinking for molecular science.",
    "expanded_description": "This lesson introduces students to the fundamental ways molecules are represented in computational chemistry and cheminformatics, with a focus on practical skills using Jupyter notebooks. Students will explore how chemical structures are encoded as data (e.g., SMILES, InChI, and molecular graphs), and learn to manipulate and visualize these representations using Python.\n\nDesigned for introductory chemistry students with beginner programming experience, the module bridges core chemical concepts with modern computational tools. Through hands-on activities, students will gain experience reading, interpreting, and generating molecular representations, and will use open-source libraries to analyze and visualize molecular structures.\n\nBy the end of the lesson, students will understand the importance of molecular representations in computational science, be able to apply basic programming to chemical problems, and develop foundational skills for further study in cheminformatics and molecular modeling. This lesson supports the integration of computational thinking into general chemistry curricula and prepares students for more advanced topics in molecular science.\n",
    "programming_skill": "Beginner",
    "primary_course": "General Chemistry",
    "authors": [
      "Prof. Kevin P. Greenman"
    ],
    "estimated_time": "2-3 hours",
    "format": "Multi-Part Materials Module",
    "instructor_email": "kgreenman@catholic.tech",
    "student_level": "Undergraduate - First/Second Year",
    "students_piloted": 15,
    "instructor_notes": "Additional context for instructors using this lesson:\n\n- These materials are under development and will be first piloted in a course in Fall 2025.  \n",
    "public_repo_url": "https://github.com/act-cms/molecular-representations",
    "materials": [
      {
        "title": "Chemistry Visualization",
        "description": "Visualize chemical structures in 2D and 3D using Python tools. Learn to represent molecules graphically and understand the basics of cheminformatics visualization.",
        "type": "notebook",
        "duration": "20 min",
        "github_url": "https://github.com/act-cms/molecular-representations/blob/main/1-chemistry_visualisation.ipynb",
        "objectives": [
          "Understand how to visualize molecules in 2D and 3D.",
          "Use Python libraries to display and manipulate chemical structures."
        ]
      },
      {
        "title": "Conformers: Exploring Molecular Flexibility",
        "description": "Explore the concept of molecular conformers and how different conformations affect molecular properties. Generate and analyze conformers computationally.",
        "type": "notebook",
        "duration": "20 min",
        "github_url": "https://github.com/act-cms/molecular-representations/blob/main/2-conformers.ipynb",
        "objectives": [
          "Define and generate molecular conformers.",
          "Analyze the impact of conformational changes on molecular properties."
        ]
      },
      {
        "title": "Digital Chemistry Representations",
        "description": "Learn about digital representations of molecules, including SMILES and InChI. Practice converting between different formats and understand their computational uses.",
        "type": "notebook",
        "duration": "20 min",
        "github_url": "https://github.com/act-cms/molecular-representations/blob/main/3-digital_chemistry_representations.ipynb",
        "objectives": [
          "Describe common digital representations for molecules.",
          "Convert between SMILES, InChI, and other formats."
        ]
      },
      {
        "title": "Hybridisation in Chemistry",
        "description": "Investigate the concept of hybridisation and how it explains molecular geometry and bonding. Use computational tools to assign hybridisation states.",
        "type": "notebook",
        "duration": "20 min",
        "github_url": "https://github.com/act-cms/molecular-representations/blob/main/4-hybridisation.ipynb",
        "objectives": [
          "Explain the concept of atomic hybridisation.",
          "Assign hybridisation states to atoms in molecules."
        ]
      },
      {
        "title": "VSEPR and Molecular Geometry",
        "description": "Apply Valence Shell Electron Pair Repulsion (VSEPR) theory to predict and visualize molecular shapes.",
        "type": "notebook",
        "duration": "20 min",
        "github_url": "https://github.com/act-cms/molecular-representations/blob/main/5-vsepr_geometry.ipynb",
        "objectives": [
          "Predict molecular geometry using VSEPR theory.",
          "Visualize 3D molecular shapes and relate them to electron pair arrangements."
        ]
      },
      {
        "title": "Bond Types and Chemical Structure",
        "description": "Differentiate between ionic, covalent, and other bond types. Explore how bond types influence molecular properties and representations.",
        "type": "notebook",
        "duration": "20 min",
        "github_url": "https://github.com/act-cms/molecular-representations/blob/main/6-bond_types.ipynb",
        "objectives": [
          "Identify and compare different types of chemical bonds.",
          "Relate bond types to molecular structure and reactivity."
        ]
      },
      {
        "title": "Working with Chemistry Data",
        "description": "Read, clean, and visualize chemical datasets using Python. Learn to handle SMILES strings and property data for cheminformatics analysis.",
        "type": "notebook",
        "duration": "20 min",
        "github_url": "https://github.com/act-cms/molecular-representations/blob/main/7-chemistry_data.ipynb",
        "objectives": [
          "Import and manipulate chemical data in Python.",
          "Visualize and analyze chemical datasets."
        ]
      },
      {
        "title": "Introduction to Chemprop and Machine Learning",
        "description": "Train a basic Chemprop machine learning model on chemical data. Visualize regression results and understand the basics of molecular property prediction.",
        "type": "notebook",
        "duration": "30 min",
        "github_url": "https://github.com/act-cms/molecular-representations/blob/main/8-chemprop_machine_learning.ipynb",
        "objectives": [
          "Train a simple machine learning model for molecular property prediction.",
          "Interpret and visualize model results using Python tools."
        ]
      }
    ],
    "scientific_objectives": [
      "Predict the molecular geometry of simple molecules using Valence Shell Electron Pair Repulsion (VSEPR) theory",
      "Describe the concept of hybridization and determine the hybridization state of the central atom in molecules, correctly identifying sp, sp², sp³, sp³d, and sp³d² hybridizations",
      "Identify and differentiate between ionic and covalent bonds based on electronegativity differences and electron transfer/sharing mechanisms",
      "Translate between different representations of chemical structures (e.g., Lewis structures, SMILES, 3D models)",
      "Select and justify the most suitable chemical representation for a specific scientific or computational task"
    ],
    "cyberinfrastructure_objectives": [
      "Read and write chemical data in the form of SMILES strings and property values from CSV files using Pandas in Python",
      "Clean and visualize chemical datasets using Pandas, RDKit, and other Python libraries/operations",
      "Use GPU computing resources to train a basic Chemprop and other machine learning models",
      "Visualize results of machine learning regression using Matplotlib and Seaborn"
    ],
    "scientific_prerequisites": [
      "High school level mathematics",
      "Basic understanding of scientific concepts"
    ],
    "programming_prerequisites": [
      "Basic Python syntax (variables, loops, functions)"
    ],
    "platforms": [
      "Local Installation"
    ],
    "recommended_platform": "Local Installation",
    "tags": [
      "python",
      "machine-learning",
      "visualization"
    ],
    "id": "molecular-representations",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "molecular-representations"
  },
  {
    "title": "Buffer Preparation Calculations",
    "description": "Calculations to guide reagent use when preparing a buffer solution at a given pH.",
    "expanded_description": "This lesson can be used to guide reagent use by students when preparing a buffer solution in an analytical chemistry laboratory.\nThe suggested context would be to walk through it together in the analytical laboratory before preparing the buffer solutions.\nQuantities may need to be revised and recalculated during the laboratory if a student's buffer solution does not meet specifications.\nAbout an hour during lab should be allocated to this module; students may also ask questions when recalculating.\n",
    "programming_skill": "None",
    "primary_course": "Analytical Chemistry",
    "also_for": [
      "Biochemistry",
      "Physical Chemistry"
    ],
    "authors": [
      "Dr. Christine Morales"
    ],
    "estimated_time": "1 hour",
    "format": "Single Notebook",
    "instructor_email": "moralech@mountunion.edu",
    "student_level": "Undergraduate - Second Year",
    "students_piloted": 10,
    "instructor_notes": "This module provides practice to reinforce programming concepts introduced in prior modules for students with no prior coding experience.\n\nTeaching tips:\n- This lesson reinforces the utility of variables and functions for quickly recalculating important quantities.\n- Students may safely use a scale factor larger than 25 to achieve sufficient buffer capacity; potentially up to 100.\n  Of course the scale factor can be increased beyond 100, but needing to do so may be a sign of cross-contamination.\n- After changing the scale factor, students must re-run both Task 3 and Task 4 to recalculate reagent quantities.\n- For students with a liquid acid, this lesson illustrates the use of commented-out code for contingent use cases.\n- Students should be reminded to always add acid to water, never water to acid, and preferably to do so in the hood.\n- While this lesson is not as challenging as others, that can compensate for the technical challenge of buffer preparation.\n  Its ease of use promotes good planning prior to preparation of buffers, which is an important analytical laboratory skill.\n- Students should be permitted to consult with others, to ensure they are accountable to understand each part.\n- Encourage students to share ideas but code/answer questions in their own copy of the notebook.\n- Remind students to save their own copy before they begin work.\n- Some students may have several Google accounts; remind them to be aware of which account is logged in when they save.\n\nTiming notes:\n- Task 1 typically takes students 5-10 minutes.\n- Task 2 typically takes students 5-10 minutes.\n- Task 3 typically takes students 10-15 minutes, as savvy students may debate increasing the scale factor right away.  \n  If they do so, they are less likely to need to recalculate and re-make their solution with a higher buffer capacity.\n- Task 4 typically takes students 10-15 minutes, as students decide if their acid is a solid or a liquid, decide what\n  to do with the commented-out code for liquid acids, and look up the needed molar masses and (if needed) density.\n- If necessary, recalculating with a higher scale factor (Tasks 3 and 4) should take students no more than 5 minutes.\n\nCommon student questions:\n- Students may ask if they should just start with an increased scale factor.\n- Students may ask how to dispense liquid acids.  Micropipettes are the most accurate, but MUST be handled very carefully.\n  Please supervise students if they have not yet been trained in safe handling of micropipettes.\n- Students may ask if the Henderson-Hasselbalch equation is sufficiently accurate.  This does not account for small ionic\n  strength effects on pH, but it greatly simplifies the code, and it should be sufficiently accurate for this purpose.\n",
    "related_modules": [
      "moralech-umu-basic-tasks",
      "statistical-testing-beta",
      "solution-preparation-spectrophotometry",
      "standard-addition-spectrophotometry",
      "calibration-of-glassware",
      "ocean-acidification",
      "hplc-analysis",
      "gc-ms-internal-standard"
    ],
    "public_repo_url": "https://github.com/act-cms/buffer-solutions",
    "materials": [
      {
        "title": "Buffer Preparation Calculations",
        "description": "Generate code in Python to perform four tasks: Calculate an allowable pH range; Calculate allowable conjugate mole ratios; Calculate adjustable reagent amounts in moles; Convert amounts to measurable quantities.",
        "type": "notebook",
        "duration": "1 hour",
        "github_url": "https://github.com/act-cms/buffer-solutions/blob/main/Buffer_Preparation_Student_Version.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/buffer-solutions/blob/main/Buffer_Preparation_Student_Version.ipynb",
        "objectives": [
          "Content: Apply the concept of a pKa value to select reagents for a buffer solution",
          "Content: Apply the concept of buffer capacity to plan and prepare a buffer solution",
          "Process: Use Python code to define variables and functions, and to perform calculations",
          "Process: Use Python code to report the output of calculations in a specified format",
          "Process: Understand how to redefine variables and re-run code if necessary"
        ]
      }
    ],
    "scientific_objectives": [
      "Apply the concept of a pKa value to select reagents for a buffer solution",
      "Apply the concept of buffer capacity to plan and prepare a buffer solution"
    ],
    "cyberinfrastructure_objectives": [
      "Use Python code to define variables and functions, and to perform calculations",
      "Use Python code to report the output of calculations in a specified format",
      "Understand how to redefine variables and re-run code if necessary"
    ],
    "scientific_prerequisites": [
      "General chemistry",
      "The pH Scale and pKa Values",
      "Buffer Solutions",
      "The Henderson-Hasselbalch Equation"
    ],
    "programming_prerequisites": [
      "No prior programming experience required"
    ],
    "platforms": [
      "Google Colab",
      "Local Installation",
      "ChemCompute"
    ],
    "recommended_platform": "Google Colab",
    "tags": [
      "python",
      "analytical-chemistry",
      "laboratory",
      "data-analysis"
    ],
    "id": "buffer-solutions",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "buffer-solutions",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/buffer-solutions&branch=main&urlpath=lab/tree/buffer-solutions/"
  },
  {
    "title": "Building a Data Analysis Pipeline: The Kinetics of the Chemiluminescence of Bleach",
    "description": "Students will learn to to automate the fitting of a set of datafiles.",
    "expanded_description": "This module is a pair of notebooks designed to teach students how to batch process a set of experimental datafiles, rather than working with each file individually. Students are first taken through fitting one file with an eye towards automation. In the second notebook, two automation options are described. The first, 'soft' automation, simply gives an organization to fitting a moderate number of files by hand. The second teaches students to use glob to find all files of a given type and then use a for loop to fit all files.\n\nThe provided datafiles show the chemiluminescence of bleach when reacted with luminol and peroxide. These files show a sharp rise from the initial reaction, then an exponential decay that has different rates depending on the concentration of the reactants. These notebooks are easily adapted to any set of experimental data showing an exponential decay, common in many kinetics experiments.\n",
    "programming_skill": "Beginner",
    "primary_course": "Physical Chemistry Lab",
    "also_for": [
      "Physical Chemistry",
      "Analytical Chemistry Lab",
      "Analytical Chemistry"
    ],
    "authors": [
      "Prof. Marie van Staveren"
    ],
    "estimated_time": "2-3 hours",
    "format": "Multi-Part Materials Module",
    "instructor_email": "instructor-access@university.edu",
    "student_level": "Undergraduate - Third Year",
    "students_piloted": 3,
    "instructor_notes": "Additional context for instructors using this lesson:\n\n- These notebooks are intended to support students in analyzing their experimental data\n- The piloted assessment was a separate lab report, so there is no formal assessment within this module\n- Students typically don't complete every step in order. Instead they work at what they need help with.\n- Students often struggle with how close initial parameter guesses need to be\n\nTiming notes:\n- Part 1 typically takes students 30 - 45 minutes\n- Part 2 takes between 1 and 2 hours\n",
    "related_modules": [
      "vibronic-spectrum-iodine"
    ],
    "public_repo_url": "https://github.com/act-cms/chemiluminescence-of-bleach",
    "materials": [
      {
        "title": "Part 1: Fitting the first data file",
        "description": "Fitting a single data file with an eye towards automation",
        "type": "notebook",
        "duration": "30 minutes",
        "github_url": "https://github.com/act-cms/chemiluminescence-of-bleach/blob/main/Fitting-the-first-data-file.ipynb",
        "objectives": [
          "Fitting data to an exponential",
          "Automatically determining initial guess parameters"
        ]
      },
      {
        "title": "Part 2: Fitting many data files",
        "description": "Creating a pipeline to automatically fit many data files",
        "type": "notebook",
        "duration": "90 min",
        "github_url": "https://github.com/act-cms/chemiluminescence-of-bleach/blob/main/Fitting-many-data-files.ipynb",
        "objectives": [
          "Using glob to find files",
          "Using a for loop to iterate over files",
          "Handling likely issues with automation"
        ]
      }
    ],
    "scientific_objectives": [
      "Understanding how to handle metadata from instrumental outputs",
      "The possibilities of automation to allow more complex experimental analysis"
    ],
    "cyberinfrastructure_objectives": [
      "Fit data using Scipy's curve_fit",
      "Using glob to search for files",
      "Using a for loop to automate file analysis",
      "Planning for likely problems with automatic analysis"
    ],
    "scientific_prerequisites": [
      "General chemistry",
      "Introductory level understanding of chemical kinetics"
    ],
    "programming_prerequisites": [
      "Basic Python syntax (variables, loops, functions)"
    ],
    "platforms": [
      "Local Installation",
      "ChemCompute"
    ],
    "recommended_platform": "ChemCompute",
    "tags": [
      "python",
      "kinetics",
      "data fitting",
      "automation",
      "lab"
    ],
    "id": "chemiluminescence-of-bleach",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "chemiluminescence-of-bleach",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/chemiluminescence-of-bleach&branch=main&urlpath=lab/tree/chemiluminescence-of-bleach/"
  },
  {
    "title": "Calibration of Glassware",
    "description": "Data analysis for a Calibration of Glassware Experiment in Analytical Chemistry Laboratory.",
    "expanded_description": "This lesson can be used to analyze glassware calibration data collected by students in an analytical chemistry laboratory.\nThe suggested context would be to walk through it together during the second week of Analytical Laboratory.\nAbout a half hour to an hour should be allocated in lab to this lesson.\n",
    "programming_skill": "None",
    "primary_course": "Analytical Chemistry",
    "also_for": [
      "General Chemistry",
      "Physical Chemistry"
    ],
    "authors": [
      "Dr. Christine Morales"
    ],
    "estimated_time": "1 hour or less",
    "format": "Single Notebook",
    "instructor_email": "moralech@mountunion.edu",
    "student_level": "Undergraduate - Second Year",
    "students_piloted": 10,
    "instructor_notes": "This introductory module works well as a second programming lesson for students with no coding experience.\n\nTeaching tips:\n- If your students have already done Basic Tasks and you have time, consider providing less sample code for data entry in Tasks 1 and 3.  \n- If you do not provide sample code for data entry in Tasks 1 and 3, consider prompting students to copy Numpy array data entry syntax from Basic Tasks.\n- In Task 2, the detailed formatting settings for the graph are intended to demonstrate creation of publication-quality figures, \n  for example the buret calibration graph in the Calibrating Volumetric Glassware experiment from the Quantitative Chemical Analysis textbook by Daniel C. Harris.\n- Students should work together in groups to ensure they are accountable to understand each part.\n- Encourage students to share ideas but code/answer questions in their own copy of the notebook.\n- Remind students to save their own copy before they begin work.\n- Some students may have several Google accounts; remind them to be aware of which account is logged in when they save.\n- If you do not have a full hour available in lab, consider omitting Part 4.\n- In Task 4, glassware tolerance tables are displayed as drop-down widgets.  These are not printable.  \n  If you need students to generate printable tables, consider using formatted print statments or Pandas dataframes.\n\nTiming notes:\n- Task 1 typically takes students 10-15 minutes when sample code is provided.  Add 5 minutes if prompting students to copy Numpy syntax from Basic Tasks.\n- Task 2 typically takes students 5-10 minutes.  Show students how to save and print the graph to tape into their lab notebook.\n- Task 3 typically takes students 10-15 minutes when sample code is provided.  Add 5 minutes if prompting students to copy Numpy syntax from Basic Tasks.\n- Task 4 typically takes students 5-10 minutes.  Consider omitting Task 4 if time is tight.\n\nCommon student questions:\n- Students may ask if they need to tape the graph into their laboratory notebook before turning it in.\n- Students may ask if they need to print the glassware tolerance widgets; this is not feasible.\n",
    "related_modules": [
      "moralech-umu-basic-tasks",
      "statistical-testing-beta",
      "solution-preparation-spectrophotometry",
      "standard-addition-spectophotometry",
      "ocean-acidification",
      "buffer-solutions",
      "hplc-analysis",
      "gc-ms-internal-standard"
    ],
    "public_repo_url": "https://github.com/act-cms/moralech-umu-public-calibration-of-glassware",
    "materials": [
      {
        "title": "Calibration of Glassware",
        "description": "Generate code in Python to perform four tasks: Entering and processing data as an array; Creating a publication-quality graph; Reporting results to correct significant figures; Creating and using a lookup table widget.",
        "type": "notebook",
        "duration": "1 hour",
        "github_url": "https://github.com/act-cms/moralech-umu-public-calibration-of-glassware/blob/main/Calibration_of_Glassware_Student_Version.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/moralech-umu-public-calibration-of-glassware/blob/main/Calibration_of_Glassware_Student_Version.ipynb",
        "objectives": [
          "Content: Use a water density table to convert between mass and volume",
          "Content: Use tolerance data to understand the range of random error",
          "Content: Use calibration data to correct for systematic error",
          "Process: Use Python code to enter data into arrays",
          "Process: Use Python code to perform array calculations",
          "Process: Use Python code to display data in graphs or drop-down menus"
        ]
      }
    ],
    "scientific_objectives": [
      "Use a water density table to convert between mass and volume",
      "Use tolerance data to understand the range of random error",
      "Use calibration data to correct for systematic error"
    ],
    "cyberinfrastructure_objectives": [
      "Use Python code to enter data into arrays",
      "Use Python code to perform array calculations",
      "Use Python code to display data in graphs or drop-down menus"
    ],
    "scientific_prerequisites": [
      "Types of Glassware",
      "Types and Sources of Error"
    ],
    "programming_prerequisites": [
      "No prior programming experience required"
    ],
    "platforms": [
      "Google Colab",
      "Local Installation",
      "ChemCompute"
    ],
    "recommended_platform": "Google Colab",
    "tags": [
      "python",
      "analytical-chemistry",
      "laboratory",
      "data-analysis"
    ],
    "id": "calibration-of-glassware",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "calibration-of-glassware",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/moralech-umu-public-calibration-of-glassware&branch=main&urlpath=lab/tree/moralech-umu-public-calibration-of-glassware/"
  },
  {
    "title": "Diffusion from the Atomistic to Continuum Scale",
    "description": "Explore ways to measure and model diffusion computationally, starting with molecular dynamics in a web app and then moving to a Fickian continuum description.",
    "expanded_description": "Explore diffusion at multiple lengthscales, no coding experience required! \nStudents will start by collecting their \"experimental\" data using a 2D molecular dynamics (MD) web app and \nby stepping through this notebook, will see how one can extract a diffusivity from mean squared displacement\nacross particles. \n\nNext, they will connect this to the continuum (Fick's Laws) description and investigate how the intuitive notion\nof diffusion (how material \"spreads out\") connects to the atomistic picture from Brownian motion.\n\nAlong the way, there are prompts to reflect on both the conceptual content as well as the complementarity between\nthe experimental and computational paradigms.\n",
    "programming_skill": "None",
    "primary_course": "Materials Science",
    "also_for": [
      "Physical Chemistry"
    ],
    "authors": [
      "Prof. Rachel C. Kurchin"
    ],
    "estimated_time": "2-3 hours",
    "format": "Single notebook",
    "instructor_email": "rkurchin@cmu.edu",
    "student_level": "Undergraduate - First Year",
    "students_piloted": 30,
    "instructor_notes": "Additional context for instructors using this lesson:\n\nThis activity is designed as a lab activity to expose students to some techniques and capabilities of computational materials science with no programming prerequisites. That is, all they have to do with this Jupyter notebook is run existing cells of code and in some cases paste in data or change one number. My goals were to get the students thinking about how computation as a paradigm is distinct from pure theory and can complement both theory and experiment, e.g. by probing scales of length and time inaccessible in a physical lab, or through massive replication through automation.\n\nWhen I piloted this activity (in Carnegie Mellon's introductory materials science course), it was actually before they had seen anything about diffusion in the associated lecture. I think it could work well in either scenario, though, it would just affect how technical one should expect the students to get in their responses to the reflection prompts, and also what context would be needed in the prelab mini-lecture. My pilot audience was also extremely heterogeneous in programming background, some first-year undergraduates with essentially no experience, and some more senior computer science students, and it worked just fine.\n\nFor my course, the deliverable was a standard lab memo that included responses to the reflection prompts within the notebook, as well as this additional prompt: \"Please also write at least a few sentences reflecting on computation as an \"experimental\" paradigm generally. How do you see it as similar to or different from experiments? What can we learn about diffusion more easily from one approach compared to the other?\"\n\nLogistical tips, and things to emphasize in prelab mini-lecture:\n- Demonstrate launching the notebook in chosen platform (I suggest ChemCompute), including setting the correct runtime!\n- Demonstrate using the online MD tool and getting the density up high enough (easiest technique is to use the \"freeze\" button and then drag the number slider up repeatedly)\n- Since the first two setup cells to install and import packages will take a few minutes to run, try to make sure students get those going first and then start reading and exploring the MD engine, etc.\n\nSome student \"gotchas\" I ran into a few times:\n- Not setting the correct runtime (e.g. they're in Python instead of Julia) so none of the code runs\n- Not evaluating the cells after pasting their data in\n- Data formatting issues due to either not pasting in the full contents of the data dump, resetting stats during data collection, etc.\n\nPossibilities to \"level up\" this activity for more advanced students:\n- Connect to 2D Lennard-Jones phase diagram (conditions here are in the two-phase solid-liquid region!) and thinking about why solid ends up in middle of box and liquid along the edges (see e.g. [here](https://www.researchgate.net/publication/49750821/figure/fig1/AS:667216336936969@1536088179352/Phase-diagram-of-2D-Lennard-Jones-solid-as-given-in-9-The-first-order-boundaries-are.png))\n- \"Skeletonize\" some of the code cells and ask students to fill in some of the analysis or visualization themselves\n- Get more in-depth into what's going on with the MD, understand why temperature drifts, etc.\n- Have them repeat the second portion at another temperature and think about how/why the results change\n- Dive more into some of the PDE stuff at the end\n",
    "public_repo_url": "https://github.com/rkurchin/27100_diffusion_computational_lab",
    "materials": [
      {
        "title": "Diffusion Computational Lab",
        "description": "Explore diffusion computationally at atomistic and continuum lengthscales.",
        "type": "notebook",
        "duration": "2-3 hours",
        "github_url": "https://github.com/rkurchin/27100_diffusion_computational_lab/blob/main/diffusion_computational_lab.ipynb",
        "colab_url": "https://colab.research.google.com/github/rkurchin/27100_diffusion_computational_lab/blob/main/colab/diffusion_computational_lab_colab.ipynb",
        "objectives": [
          "Understand how we measure and model diffusion computationally at both atomistic and continuum scales",
          "Consider complementarity between computational and experimental paradigms"
        ]
      }
    ],
    "scientific_objectives": [
      "Observe diffusive processes in an atomistic simulation",
      "Explain how we can compute a diffusivity from the slope of MSD vs. time",
      "Connect these atomistic mechanisms to the continuum (Fickian) description"
    ],
    "cyberinfrastructure_objectives": [
      "Handle tabular data",
      "Interact with a literate programming environment (Jupyter)",
      "Interpret parameters from a model fit",
      "Consider complementarity between computational and experimental paradigms"
    ],
    "scientific_prerequisites": [
      "High school chemistry/physics",
      "High school algebra/precalc"
    ],
    "programming_prerequisites": [
      "No prior programming experience required"
    ],
    "platforms": [
      "ChemCompute",
      "Google Colab",
      "Local Installation"
    ],
    "recommended_platform": "ChemCompute",
    "tags": [
      "julia",
      "molecular-dynamics",
      "visualization",
      "diffusion",
      "materials-science"
    ],
    "id": "diffusion",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "diffusion",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/rkurchin/27100_diffusion_computational_lab&branch=main&urlpath=lab/tree/27100_diffusion_computational_lab/"
  },
  {
    "title": "Foundations of Symbolic Mathematics in Python",
    "description": "Students will be introduced to the fundamentals of symbolic mathematical manipulations in Python.",
    "expanded_description": "The lessons in this module are meant to help students develop foundational\nskills in symbolic mathematics, including algebra, calculus, linear algebra,\ndifferential equations, and beyond --- but decoupled from any particular chemistry\ncourse or chemical application beyond the general chemistry level.\n",
    "programming_skill": "Beginner",
    "primary_course": "Foundational Module",
    "also_for": [
      "General Chemistry",
      "Physical Chemistry",
      "Biophysical Chemistry",
      "Materials Science",
      "Analytical Chemistry"
    ],
    "authors": [
      "Prof. Dom Sirianni"
    ],
    "estimated_time": "3 hours",
    "format": "Multi-Part Module",
    "instructor_email": "sirianni.dom@gmail.com",
    "student_level": "Undergraduate (all years)",
    "students_piloted": 15,
    "instructor_notes": "Additional context for instructors using this lesson:\n- Prerequisite of basic Python programming (equivalent to outcome of related module)\n- Symbolic algebra lesson is prerequisite for other lessons\n\nTiming notes:\n- Symbolic algebra lesson can be completed in single 3-hour lab period\n\nCommon student questions:\n- \"I can solve these problems by hand, why do I need to use Python?\" \n- Remind students that some chemical problems in sophomore-level courses & beyond are either impossible or backbreakingly difficult to solve by hand, so developing these skills will greatly help their progress through the curriculum\n",
    "related_modules": [
      "foundational-intro-python"
    ],
    "public_repo_url": "https://github.com/act-cms/foundational-symbolic-math",
    "materials": [
      {
        "title": "Foundations of Symbolic Algebra in Python",
        "description": "Basics of using `sympy` and `algebra_with_sympy` libraries to symbolically solve general chemistry problems",
        "type": "notebook",
        "duration": "3 hours",
        "github_url": "https://github.com/act-cms/foundational-symbolic-math/blob/main/symbolic-algebra/symbolic-algebra-async.ipynb",
        "objectives": [
          "Define algebraic variables and expressions using the `algebra_with_sympy` library",
          "Manipulate algebraic expressions to solve for a single variable",
          "Substitute numerical values and units to evaluate algebraic expressions",
          "Automatically solve algebraic expressions for a single variable",
          "Apply `algebra_with_sympy` to symbolically solve chemical problems at the first-year general chemical level"
        ]
      }
    ],
    "scientific_objectives": [
      "Apply symbolic mathematical operations in Python to solve general chemical problems"
    ],
    "cyberinfrastructure_objectives": [
      "Define algebraic variables and expressions using the `algebra_with_sympy` library",
      "Manipulate algebraic expressions to solve for a single variable",
      "Substitute numerical values and units to evaluate algebraic expressions",
      "Automatically solve algebraic expressions for a single variable",
      "Apply `algebra_with_sympy` to symbolically solve chemical problems at the first-year general chemical level"
    ],
    "scientific_prerequisites": [
      "General chemistry: gas laws, chemical kinetics, thermochemistry, Bohr model of the atom & wave nature of light, chemical equilibrium"
    ],
    "programming_prerequisites": [
      "Basic Python syntax (variables, loops, functions, lists)"
    ],
    "platforms": [
      "Local Installation"
    ],
    "recommended_platform": "Local Installation",
    "tags": [
      "python",
      "symbolic-math",
      "symbolic-algebra"
    ],
    "id": "foundational-symbolic-math",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "foundational-symbolic-math"
  },
  {
    "title": "Gas Chromatography – Mass Spectrometry with Internal Standard",
    "description": "Data analysis for a Gas Chromatography – Mass Spectrometry Experiment with an Internal Standard in Analytical Chemistry Laboratory.",
    "expanded_description": "This lesson can be used to analyze GC-MS peak area data collected by students in an analytical chemistry laboratory.\nThe suggested context would be to walk through it together in the analytical laboratory after data collection, likely in the second week of a 2-week sequence.\nEven with relatively short run times and an autosampler, it is not feasible to prepare samples, run the GC, and analyze GC data in one lab period.\nAt least an hour at the end of the lab period should be allocated to this data analysis module.\n",
    "programming_skill": "None",
    "primary_course": "Analytical Chemistry",
    "also_for": [
      "Environmental Chemistry"
    ],
    "authors": [
      "Dr. Christine Morales"
    ],
    "estimated_time": "60-90 minutes",
    "format": "Single Notebook",
    "instructor_email": "moralech@mountunion.edu",
    "student_level": "Undergraduate - Second Year",
    "students_piloted": 10,
    "instructor_notes": "This module provides practice to reinforce array-based programming skills introduced in prior modules for students with no prior coding experience.\n\nTeaching tips:\n- If time permits, consider reviewing internal standard calculations to assist students with interpreting functions in Tasks 3 and 4.\n- In Task 1, students ideally should decide *as a class* whether to enter single-valued data or a NumPy array of replicate data points,\n  and discuss as a team how to swap the lines of sample-code that are commented out if needed.\n  However, there is no prompt for this in the notebook because our students did not have time to prepare replicate samples.\n- If time permits, consider asking students to write their own code to perform dilution calculations in Task 2.  This could also be assigned\n  as a pre-lab exercise, with sample code available as a last resort (perhaps at the cost of those pre-lab points).\n- In Task 4, students ideally should review *as a class* whether to vectorize the defined function, and discuss as a team\n  how to swap the lines of sample-code that are commented out if needed. As in Task 1 however, there is no prompt for this in the notebook\n  because our students did not have time to prepare replicate samples.\n- Ideally, this module could be good practice for students to think about how to code with NumPy arrays.  If there is time\n  in the first week for students to prepare replicate samples, prompts can be added for students to discuss these decisions as a class.\n- This increased focus on arrays assumes a prior introduction to NumPy arrays and data entry in prior modules. If that is not the case,\n  the instructor may make all coding decisions for the class and treat the module as more of a basic introduction to array handling.\n\nTiming notes:\n- Task 1 typically takes students 10-15 minutes.  Add 5-10 minutes if the class will discuss whether to use NumPy arrays of replicate data.\n- Task 2 typically takes students 5-10 minutes.  Add 15-20 minutes or a pre-lab assignment if asking students to write their own code here.\n- Task 3 typically takes students 5-10 minutes.  \n- Task 4 typically takes students 10-15 minutes.  Add 5-10 minutes if the class will discuss whether to use NumPy arrays of replicate data.\n\nCommon student questions:\n- Some students may struggle to recall dilution factors if asked to write their own code in Task 2.\n- Students may ask why they should use an internal standard instead of a calibration curve when analyzing GC-MS peak areas.\n- If provided with chromatograms, students may think they need to enter retention times in addition to peak areas.\n- If Selected Ion Monitoring (SIM) is used and not explained, students may ask why they cannot see the other peaks in chromatograms.\n",
    "related_modules": [
      "moralech-umu-basic-tasks",
      "statistical-testing-beta",
      "solution-preparation-spectrophotometry",
      "standard-addition-spectrophotometry",
      "calibration-of-glassware",
      "ocean-acidification",
      "buffer-solutions",
      "hplc-analysis"
    ],
    "public_repo_url": "https://github.com/act-cms/gc-ms-internal-standard",
    "materials": [
      {
        "title": "Part 1: Introduction",
        "description": "Brief description of what this notebook covers",
        "type": "notebook",
        "duration": "1 hour",
        "github_url": "https://github.com/act-cms/gc-ms-internal-standard/blob/main/GC-MS_Internal-Standard_Student_Version.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/gc-ms-internal-standard/blob/main/GC-MS_Internal-Standard_Student_Version.ipynb",
        "objectives": [
          "Content: Explain how using an internal standard permits quantitative analysis of an analyte using a measurement technique such as gas chromatography (GC) in which the signal can fluctuate",
          "Content: Explain how mass spectrometry (MS) permits the selection of an ideal internal standard",
          "Content: Calculate an internal standard response factor from ratios in a measured signal, and use it to find the concentration of an analyte",
          "Process: Use Python code to transform data using structures such as arrays",
          "Process: Use Python code to transform data using functions"
        ]
      }
    ],
    "scientific_objectives": [
      "Explain how using an internal standard permits quantitative analysis of an analyte using a measurement technique such as gas chromatography (GC) in which the signal can fluctuate",
      "Explain how mass spectrometry (MS) permits the selection of an ideal internal standard",
      "Calculate an internal standard response factor from ratios in a measured signal, and use it to find the concentration of an analyte"
    ],
    "cyberinfrastructure_objectives": [
      "Use Python code to transform data using structures such as arrays",
      "Use Python code to transform data using functions"
    ],
    "scientific_prerequisites": [
      "General chemistry",
      "Concept of an internal standard for use in calibration of an instrument signal"
    ],
    "programming_prerequisites": [
      "Basic Python syntax (variables, arrays, functions)"
    ],
    "platforms": [
      "Google Colab",
      "Local Installation",
      "ChemCompute"
    ],
    "recommended_platform": "Google Colab",
    "tags": [
      "python",
      "analytical-chemistry",
      "laboratory",
      "data-analysis"
    ],
    "id": "gc-ms-internal-standard",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "gc-ms-internal-standard",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/gc-ms-internal-standard&branch=main&urlpath=lab/tree/gc-ms-internal-standard/"
  },
  {
    "title": "High-Performance Liquid Chromatography Analysis",
    "description": "Data analysis for a High-Performance Liquid Chromatography Experiment in Analytical Chemistry Laboratory.",
    "expanded_description": "This lesson can be used to analyze chromatographic retention time and peak area data collected by students in an analytical chemistry laboratory.\nThe suggested context would be to walk through it together in the analytical laboratory after data collection, likely in the second week of a 2-week sequence.\nEven with relatively short run times and an autosampler, it is not feasible to prepare samples, run the HPLC, and analyze HPLC data in one lab period. \nAlternatively, the HPLC Simulator on Chem Compute could be used to generate data and this lesson could be used to analyze data within one lab period.\n(Perri, M. J. 'Online Data Generation in Quantitative Analysis: Excel Spreadsheets and an Online HPLC Simulator Using a Jupyter Notebook on the Chem Compute Web site',\n*J. Chem. Educ.* **2020**, *97*, 2950–2954).  At least an hour at the end of the lab period should be allocated to this data analysis module.\n",
    "programming_skill": "None",
    "primary_course": "Analytical Chemistry",
    "also_for": [
      "Biochemistry",
      "Environmental Chemistry"
    ],
    "authors": [
      "Dr. Christine Morales"
    ],
    "estimated_time": "1-2 hours",
    "format": "Single notebook",
    "instructor_email": "moralech@mountunion.edu",
    "student_level": "Undergraduate - Second Year",
    "students_piloted": 10,
    "instructor_notes": "This module provides practice to reinforce programming skills introduced in prior modules for students with no prior coding experience.\n\nTeaching tips:\n- If time permits, consider reviewing the concepts of retention time and peak area to assist students with interpreting data from chromatograms.\n- Data organization in Task 1 is potentially challenging, hence the pre-existing, blank NumPy arrays in the sample code.\n- The linear regression and calibration curves in Task 2 should be fairly straightforward, except for the space-saving choice of making a three-part graph.  \n  If time permits, consider asking students to modify code from a prior module to generate calibration curves for each analyte.\n- Task 3 is intended to reinforce the *concepts* of retention time and spiking, but does *not* use the standard addition method to estimate concentration.  \n- Task 4 contains code that is analogous to that of Task 4 of the Solution Preparation Spectrophotometry module.  If time permits,\n  consider asking students to (substantially) modify that code to implement it in triplicate, in the new context of HPLC peak area analysis.\n  Note that a dilution factor and a unit conversion also are required here, which were not present in the prior module.  Consider providing the sample-code \n  to at least perform the dilution and unit conversion and print out results.\n\nTiming notes:\n- Task 1 typically takes students 15-20 minutes, mainly due to the volume and complexity of data entry required.  \n- Task 2 typically takes students 5-10 minutes with sample code.  Add 15-20 minutes if asking students to copy/paste/modify code from\n  a prior module to construct three linear regression models and three calibration curves with error bars.\n- Task 3 typically takes students 10-15 minutes.\n- Task 4 typically takes students 10-15 minutes with sample code.  Add 30-45 minutes if asking students to (substantially) modify code  \n  from a prior module to calculate three analyte concentrations and propagated uncertainties.  \n\nCommon student questions:\n- There is a lot going on in Task 1; students may get confused about data entry even with all sample-code provided.\n- Students may be confused about the purpose of Task 3, possibly because the standard addition method is *not* used here to estimate concentration.\n- Students may ask why calibration curves are used here instead of standard additions to calculate accurate concentrations.\n",
    "related_modules": [
      "moralech-umu-basic-tasks",
      "statistical-testing-beta",
      "solution-preparation-spectrophotometry",
      "standard-addition-spectrophotometry",
      "calibration-of-glassware",
      "ocean-acidification",
      "buffer-solutions",
      "gc-ms-internal-standard"
    ],
    "public_repo_url": "https://github.com/act-cms/hplc-analysis",
    "materials": [
      {
        "title": "High-Performance Liquid Chromatography Analysis",
        "description": "Generate code in Python to perform four tasks: Input concentration, volume, retention time and peak area data; Apply linear-least-squares analysis to generate calibration curves; Identify chromatogram peaks using data from spiked samples; Use calibration curves, peak area data and solution stoichiometry to calculate analyte concentrations and propagated uncertainty.",
        "type": "notebook",
        "duration": "1-2 hours",
        "github_url": "https://github.com/act-cms/hplc-analysis/blob/main/HPLC_Analysis_Student_Version.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/hplc-analysis/blob/main/HPLC_Analysis_Student_Version.ipynb",
        "objectives": [
          "Content: Explain how using high-performance liquid chromatography (HPLC) permits separation of a mixture into more than one analyte, using retention times to identify well-separated peaks for each analyte",
          "Content: Explain how spiked samples permit verification of each analyte's identity and estimation of each analyte's concentration",
          "Content: Explain how calibration curves permit quantitative analysis of each analyte",
          "Process: Use Python code to transform data using structures such as arrays",
          "Process: Use Python code to visualize data using different types of graphs",
          "Process: Use Python code to transform data using functions"
        ]
      }
    ],
    "scientific_objectives": [
      "Explain how using high-performance liquid chromatography (HPLC) permits separation of a mixture into more than one analyte, using retention times to identify well-separated peaks for each analytes",
      "Explain how spiked samples permit verification of each analyte's identity and estimation of each analyte's concentration",
      "Explain how calibration curves permit quantitative analysis of each analyte"
    ],
    "cyberinfrastructure_objectives": [
      "Use Python code to transform data using structures such as arrays",
      "Use Python code to visualize data using different types of graphs",
      "Use Python code to transform data using functions"
    ],
    "scientific_prerequisites": [
      "General chemistry",
      "Basic understanding of chromatographic separations"
    ],
    "programming_prerequisites": [
      "No prior programming experience required"
    ],
    "platforms": [
      "Google Colab",
      "Local Installation",
      "ChemCompute"
    ],
    "recommended_platform": "Google Colab",
    "tags": [
      "python",
      "analytical-chemistry",
      "laboratory",
      "data-analysis"
    ],
    "id": "hplc-analysis",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "hplc-analysis",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/hplc-analysis&branch=main&urlpath=lab/tree/hplc-analysis/"
  },
  {
    "title": "How can we calculate the entropy of substances?",
    "description": "In two guided-inquiry Jupyter notebooks, students fit experimental Cp data to calculate third law entropies.",
    "expanded_description": "In two guided-inquiry Jupyter notebook activities, students import experimental isobaric heat capacity data, fit the data to a polynomial, and calculate the third law entropies for several substances. The introductory notebook focuses on calculating the entropy of a substance in the solid phase using the Debye extrapolation. The second notebook introduces entropy calculations with phase changes.\n\nThe activities were designed using a guided-inquiry framework and targeted for undergraduate physical chemistry course. Students have a basic understanding of using Jupyter notebooks and importing well-formed CSV files for plotting with matplotlib. Parts of the activities are worked individually, but there are frequent prompts to reflect upon or compare results with group members.\n",
    "programming_skill": "Beginner",
    "primary_course": "Physical Chemistry",
    "also_for": [
      "Materials Science"
    ],
    "authors": [
      "Prof. Steve Singleton"
    ],
    "estimated_time": "2-3 hours for each notebook",
    "format": "Multi-Part Materials Module",
    "instructor_email": "ssinglet@coe.edu",
    "student_level": "Undergraduate",
    "students_piloted": 15,
    "instructor_notes": "\nThese activities have been used in a Physical Chemistry I course with 5-15\nstudents in a 3-hr laboratory period, 2-3 students per group. Students have\nhad basic instruction on python/Jupyter and are comfortable using\nspreadsheets, but have had no formal instruction on programming. Students\nhave been introduced to the 1st, 2nd, and 3rd laws of thermodynamics through\nPOGIL exercises. They were familiar with mathematical relationships, but had\nnot applied them to real systems.\n\nTiming notes: Each activity takes 2-3 hrs to complete. However, the notebooks\nhave natural break points to accommodate time constraints.\n",
    "public_repo_url": "https://github.com/act-cms/calculating-entropies",
    "materials": [
      {
        "title": "Part 1: How can we calculate the entropy of a solid?",
        "description": "Calculating the entropy of a solid from experimental Cp data",
        "type": "notebook",
        "duration": "2-3 hours",
        "github_url": "https://github.com/act-cms/calculating-entropies/blob/main/01-entropy-single-phase/calculating-entropyorg.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/calculating-entropies/blob/main/01-entropy-single-phase/calculating-entropyorg.ipynb",
        "objectives": [
          "apply the first and second laws of thermodynamics for calculating the entropy of a substance in a single phase",
          "relate heat capacity to entropy mathematically",
          "predict the effect of structure on the entropy of a substance"
        ]
      },
      {
        "title": "Part 2: Calculating entropy with phase changes",
        "description": "Calculating the molar entropy of a substance over a temperature range that spans phase changes",
        "type": "notebook",
        "duration": "2.5 hrs",
        "github_url": "https://github.com/act-cms/your-lesson-repo/blob/main/calculating-multiphase-entropyorg.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/calculating-entropies/blob/main/02-entropy-multi-phase/calculating-multiphase-entropyorg.ipynb",
        "objectives": [
          "Application of concepts from Part 1",
          "Apply the third law of thermodynamics to calculate entropy of a substance over a temperature range",
          "Calculate S for warming a substance in different phases",
          "Calculate S for phase transitions"
        ]
      }
    ],
    "scientific_objectives": [
      "Apply the first and second laws of thermodynamics for calculating the entropy of a substance",
      "Relate heat capacity to entropy mathematically",
      "Predict the effect of structure on the entropy of a substance"
    ],
    "cyberinfrastructure_objectives": [
      "Write and execute Python code in Jupyter notebooks",
      "Import and visualize structured data using numpy and matplotlib",
      "Fit experimental values to a polynomial",
      "Integrate functions numerically with python",
      "Assess the quality of fit using statistical measures RSS or SSE",
      "(optional) Use computational chemistry to obtain entropy"
    ],
    "scientific_prerequisites": [
      "Students should recognize differential relationships for Cp and S from the first and second laws of thermodynamics",
      "Students should recognize that heat capacity is temperature dependent"
    ],
    "programming_prerequisites": [
      "Basic plotting using matplotlib",
      "Creating and manipulating numpy arrays",
      "Calling library functions"
    ],
    "platforms": [
      "Local Installation",
      "CoCalc",
      "ChemCompute",
      "Google Colab"
    ],
    "recommended_platform": "Local installation, CoCalc, ChemCompute",
    "tags": [
      "python",
      "jupyter",
      "thermodynamics",
      "entropy",
      "undergraduate physical chemistry",
      "curve fitting",
      "inquiry learning",
      "group learning"
    ],
    "id": "calculating-entropies",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "calculating-entropies",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/calculating-entropies&branch=main&urlpath=lab/tree/calculating-entropies/"
  },
  {
    "title": "Introduction to Programming for Molecular Scientists",
    "description": "Learn fundamental programming concepts in Python including data types, file operations, and basic programming structures.",
    "expanded_description": "This foundational module introduces students to programming concepts essential for computational molecular science. \nStudents will learn Python basics including variables, data types, control structures, and file operations through \nhands-on exercises designed for scientific applications.\n\nThe module emphasizes practical programming skills that serve as prerequisites for more advanced computational \nlessons in chemistry and molecular sciences.\n",
    "programming_skill": "None",
    "primary_course": "Foundational Module",
    "also_for": [
      "Physical Chemistry",
      "Materials Science"
    ],
    "authors": [
      "Dr. Jessica A. Nash",
      "Prof. Ashley McDonald"
    ],
    "estimated_time": "2-3 hours",
    "format": "Multi-Part Materials Module",
    "instructor_email": "instructor-access@university.edu",
    "instructor_notes": "This introductory module works well as the first programming lesson for students with no coding experience.\n\nTeaching tips:\n- Students often need extra time with the file reading concepts in Part 2\n- Encourage students to experiment with the code examples\n- Common issue: students forget to run cells in order\n",
    "public_repo_url": "https://github.com/act-cms/foundational-intro-python",
    "materials": [
      {
        "title": "Introduction to Python",
        "description": "Introduction to Python programming language, basic data types, and operations.",
        "type": "notebook",
        "duration": "1 hour",
        "github_url": "https://github.com/act-cms/foundational-intro-python/blob/main/01-introduction-to-python.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/foundational-intro-python/blob/main/colab_notebooks/01-introduction-to-python.ipynb",
        "objectives": [
          "Understand basic Python syntax and data types",
          "Learn about setting variables, for loops, and conditionals",
          "Write simple scripts in Jupyter notebooks to perform calculations"
        ]
      },
      {
        "title": "Reading Data from a File",
        "description": "Opening files using open, reading line by line, and searching for a pattern in the file.",
        "type": "notebook",
        "duration": "1 hour",
        "github_url": "https://github.com/act-cms/foundational-modules/blob/main/intro-programming/reading_from_file.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/foundational-modules/blob/main/intro-programming/colab-notebooks/student/reading_from_file.ipynb",
        "objectives": [
          "Open a file and read its contents line by line",
          "Search for specific patterns in text files",
          "Extract relevant data from files"
        ]
      }
    ],
    "scientific_objectives": [
      "Apply programming concepts to solve basic scientific problems",
      "Connect programming fundamentals to molecular science applications"
    ],
    "cyberinfrastructure_objectives": [
      "Execute Python code in Jupyter notebook environments",
      "Understand basic programming concepts: variables, loops, conditionals",
      "Read and process data from files",
      "Debug simple programming errors",
      "Develop computational thinking skills for scientific problem-solving"
    ],
    "scientific_prerequisites": [
      "High school level mathematics",
      "Basic understanding of scientific concepts"
    ],
    "programming_prerequisites": [
      "No prior programming experience required"
    ],
    "platforms": [
      "Google Colab",
      "ChemCompute",
      "Local Installation"
    ],
    "recommended_platform": "Google Colab",
    "tags": [
      "introduction",
      "python",
      "jupyter",
      "foundational"
    ],
    "id": "foundational-intro-python",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "foundational-intro-python",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/foundational-intro-python&branch=main&urlpath=lab/tree/foundational-intro-python/"
  },
  {
    "title": "Introduction to Python using NMR data for a first year, graduate level course",
    "description": "Students are introduced to the use of Python to perform cheminformatics, \nanalyze NMR data and generate visualizations for data.\n",
    "expanded_description": "Four notebooks cover applications chemistry graduate students might need to utilize Python for routine\nanalysis of chemical structures using rdkit, processing NMR data for reaction kinetics and nuclear\nspin relaxation data, and to plot data/results. Applicable for organic, inorganic and polymer chemists \nwith little to no programming experience. Students will leave with the ability to load their own data, \nutilize published Python packages and create plots of the resultant information/data.\n\nThe material was introduced along with general NMR lectures covering introduction to NMR Physics, chemical shifts, \nspin-spin coupling, relaxation mechanisms, 1D and 2D pulse sequences and processing NMR data. Students are encouraged \nto work in teams for various questions posed in class as well as structural assignment problems. \n  \n",
    "programming_skill": "None",
    "primary_course": "Advanced Organic Chemistry",
    "also_for": [
      "Organic Chemistry",
      "Inorganic Science",
      "Other"
    ],
    "authors": [
      "Dr. Seth Veenbaas",
      "Prof. Marc ter Horst"
    ],
    "estimated_time": "4 hours",
    "format": "Multi-Part Materials Module",
    "instructor_email": "terhorst@unc.edu",
    "student_level": "Mixed Graduate/Undergraduate",
    "students_piloted": 25,
    "instructor_notes": "Additional context for instructors using this lesson:\n\n- This lesson works well when paired with instruction on NMR Spectroscopy for synthetic chemists\n- Take extra time with the first two notebooks for students new to Python programming\n- Homework is designed to show evidence students have gone through the notebooks (not to test skill development)\n\nTiming notes:\n- Part 1 (Day 0 , Python Essentials) is relatively quick and can be covered in a few minutes at the beginning of the course\n- Other parts are covered during a 45 minute class period, one per week\n- Advanced students are encouraged to work with people new to programming\n\nCommon student questions:\n- \"Why do we need Python for NMR?\"\n- \"I don't know what some of these error messages mean or how to address them.\"\n",
    "public_repo_url": "https://github.com/act-cms/python-for-nmr",
    "materials": [
      {
        "title": "Part 1: Python essentials",
        "description": "Brief description of what this notebook covers",
        "type": "notebook",
        "duration": "30 minutes",
        "github_url": "https://github.com/act-cms/python-for-nmr/blob/main/0-python-essentials/Day0_python_essentials.ipynb",
        "objectives": [
          "Open a Jupyter notebook",
          "Python logic statements, for loops, Python lists"
        ]
      },
      {
        "title": "Part 2: Introduction to cheminformatics",
        "description": "Using SMILES strings to work with rdkit",
        "type": "notebook",
        "duration": "50 min",
        "github_url": "https://github.com/act-cms/python-for-nmr/blob/main/1-intro-to-cheminformatics/Day1_rdkit.ipynb",
        "objectives": [
          "Use SMILES strings",
          "Learn how to import packages/libraries.",
          "Use rdkit library to draw and characterize molecules.",
          "Learn how to get help with tab complete and the help() function."
        ]
      },
      {
        "title": "Part 3: NMR Kinetics",
        "description": "Using Python to determine a rate constant from integrals of NMR data",
        "type": "notebook",
        "duration": "50 min",
        "github_url": "https://github.com/act-cms/python-for-nmr/blob/main/2-nmr-kinetics/Day2_NMR_kinetics.ipynb",
        "objectives": [
          "Use pandas and scipy to load and analyze NMR kinetics data.",
          "Determine the reaction order and rate constant (k) from NMR reaction monitoring data."
        ]
      },
      {
        "title": "Part 4: NMR Spin Relaxation",
        "description": "Using Python to determine a nuclear spin relaxation times (T1) from integrals of inversion recovery data",
        "type": "notebook",
        "duration": "50 min",
        "github_url": "https://github.com/act-cms/python-for-nmr/blob/main/2-nmr-kinetics/Day2_NMR_kinetics.ipynb",
        "objectives": [
          "Use pandas and scipy to load and analyze NMR kinetics data.",
          "Determine the reaction order and rate constant (k) from NMR reaction monitoring data."
        ]
      }
    ],
    "scientific_objectives": [
      "Apply Python programming to analyze NMR data",
      "Determine reaction rates from NMR data",
      "Determine nuclear spin-lattice relaxation from NMR data"
    ],
    "cyberinfrastructure_objectives": [
      "Use basic Python programming to work with a molecular database",
      "Write and execute Python code in Jupyter notebooks",
      "Use Python packages to fit and display data",
      "Create visualizations of NMR data",
      "Debug common programming errors"
    ],
    "scientific_prerequisites": [
      "General chemistry",
      "Organic Chemistry",
      "Understanding of molecular structure",
      "Experience with proton, one-dimensional NMR spectra"
    ],
    "programming_prerequisites": [
      "No prior programming experience required"
    ],
    "platforms": [
      "ChemCompute",
      "Local Installation"
    ],
    "recommended_platform": "ChemCompute",
    "tags": [
      "python",
      "NMR",
      "NMR Spectroscopy",
      "visualization",
      "reaction rate"
    ],
    "id": "python-for-nmr",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "python-for-nmr",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/python-for-nmr&branch=main&urlpath=lab/tree/python-for-nmr/"
  },
  {
    "title": "Introduction to the linear variation method",
    "description": "In this lesson students implement the linear variation method to calculate approximate solutions to the time-independent Schrodinger equation.",
    "expanded_description": "Students are introduced to basic tenets of the linear variation method for computing approximate solution to the Schrodinger equation. Sections 1 and 2 summarize the method while sections 3 and 4 introduce atomic units and the syntax for matrix diagonalization in Python. If desired, the appendix contains a worked-out example for a 2-parameter trial function to demonstrate the steps of linear variational method and to highlight the connection between matrix diagonalization and solving for the optimal set of expansion coefficients.\n\nIn part 1, the instructor leads a live coding session to demonstrate the implementation of the linear variation method for a modified particle in a box potential and the students are then asked to write their own code to solve the time-independent Schrodinger equation for a double-well potential. \n",
    "programming_skill": "Intermediate",
    "primary_course": "Physical Chemistry",
    "also_for": [
      "Physical Chemistry"
    ],
    "authors": [
      "Prof. Gergely Gidofalvi"
    ],
    "estimated_time": "3 or 6 hours (depending on implementation of part 2)",
    "format": "Multi-Part Materials Module",
    "instructor_email": "gidofalvi@gonzaga.edu",
    "student_level": "Undergraduate - Third Year",
    "students_piloted": 20,
    "instructor_notes": "Additional context for instructors using this lesson:\n\n- If needed, lesson-01-introduction-to-programming-and-python introduces students to basic programming concepts (loops, conditional statements, user-defined functions), data types (scalars, strings, vectors, and matrices), and built-in Python libraries and functions for numerical integration, curve fitting, plotting.  \n- To demonstrate the implementation of the linear variational method, it is recommended that the instructor lead a live coding session using the notebook for part 1. See approximate timing below.\n- After the live coding session students should be ready to tackle the assignment outlined in the notebook for part 2. The assignment includes using the linear variation method to compute approximate solutions for a double-well potential and to examine properties of the ground state solution. \n\nTiming notes:\n- At the beginning of the live coding session, the instructor is encouraged to spend time reviewing the key steps of applying the method (section 3 of notebook) and highlight elements of code design.  \n- A three-hour live coding session should provide enough time for the instructor to complete part 1 and demonstrate 1) the application of the method, 2) use of SciPy functions for numerical integration and linear algebra, and 3) code design and debugging. A useful example could be a particle confined to an infinite well with a raised floor in the right half of the box. Approximately 2-2.5 hours for this would be appropriate. \n- Students are then asked to write their own code to obtain approximate solutions for a modified double-well potential.  This notebook can be assigned either as homework for students to complete on their own outside of class/lab or with instructor supervision during a 3-hour lab period. \n\nCommon student questions:\n\n- \"Students need several reminders related to the use of functions\"\n- \"Students, especially those with no linear algebra background, often have questions related to diagonalization and how it is equivalent to finding the optimal coefficients in the wave function expansion (the appendix addresses this)\"\n- \"Students often get confused between the quantum number index and the matrix index due to the zero offset in Python when building the matrix representation of the Hamiltonian\"\n",
    "public_repo_url": "https://github.com/act-cms/linear-variation-method",
    "materials": [
      {
        "title": "Part 1: Linear vatiational method - live coding session",
        "description": "Jupyter notebook for instructor-led live coding session to demonstrate the implementation of the linear variation method.",
        "type": "notebook",
        "duration": "3 hours",
        "github_url": "https://github.com/act-cms/linear-variation-method/blob/main/lesson-02-linear-variation-method-live-coding-student.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/linear-variation-method/blob/main/lesson-02-linear-variation-method-live-coding-student.ipynb",
        "objectives": []
      },
      {
        "title": "Part 2: Linear variational method - double well potential",
        "description": "Jupyter notebook to assess student learning. Students are asked to write code to obtain approximate solutions to a double-well potential and examine properties of solutions.",
        "type": "notebook",
        "duration": "Approximately 2-3 hours",
        "github_url": "https://github.com/act-cms/linear-variation-method/blob/main/lesson-02-linear-variation-method-double-well-assignment-student.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/linear-variation-method/blob/main/lesson-02-linear-variation-method-double-well-assignment-student.ipynb",
        "objectives": []
      }
    ],
    "scientific_objectives": [
      "Describe the key aspects of the linear variational method",
      "Apply the linear variational method to obtain approximate solutions to the time-independent Schrodinger equation",
      "Explore dependence of tunneling probability on particle mass",
      "Explain the cost to benefit ratio of accuracy versus computational complexity"
    ],
    "cyberinfrastructure_objectives": [
      "Write code to access and modify elements of arrays and/or matrices",
      "Use SciPy libraries to solve eigenvalue equations and numerical integration",
      "Use Matplotlib to visualize data",
      "Demonstrate skills for debugging code designed for scientific applications"
    ],
    "scientific_prerequisites": [
      "Introductory quantum mechanics including the time-independent Schrodinger equation and the particle in an infinite well model."
    ],
    "programming_prerequisites": [
      "It is assumed that students are familiar with basic Python syntax including variable assignment, for loops, user-defined functions, plotting, array initialization, and utilizing Python libraries."
    ],
    "platforms": [
      "Google Colab",
      "ChemCompute"
    ],
    "recommended_platform": "ChemCompute",
    "tags": [
      "python",
      "approximation techniques",
      "linear variational method",
      "particle in a box",
      "double-well potential",
      "quantum-chemistry"
    ],
    "id": "linear-variation-method",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "linear-variation-method",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/linear-variation-method&branch=main&urlpath=lab/tree/linear-variation-method/"
  },
  {
    "title": "JupyterQuiz Tutorial for Educators",
    "description": "Learn how to embed interactive assessments into your Jupyter notebooks!",
    "expanded_description": "This is a lesson for educators that explains how to embed interactive assessments into \nJupyter notebooks using the JupyterQuiz package. It goes over basics of the package and provides\nan engineered prompt so that large language models like ChatGPT can be used to format instructor questions.\n",
    "programming_skill": "Beginner",
    "primary_course": "Instructor Tutorial",
    "authors": [
      "Dr. Jessica A. Nash"
    ],
    "estimated_time": "30-45 minutes",
    "format": "Multi-Part Materials Module",
    "instructor_email": "janash@vt.edu",
    "public_repo_url": "https://github.com/act-cms/jupyterquiz-tutorial",
    "materials": [
      {
        "title": "Introduction to JupyterQuiz",
        "description": "This notebook covers an introduction to JupyterQuiz, basic question types, and how to 'hide' quizzes from students.",
        "type": "notebook",
        "duration": "30 minutes",
        "github_url": "https://github.com/act-cms/jupyterquiz-tutorial/blob/main/jupyterquiz-tutorial.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/jupyterquiz-tutorial/blob/main/jupyterquiz-tutorial.ipynb",
        "objectives": [
          "Learn format and type of JupyterQuiz questions",
          "Import questions from an external module."
        ]
      },
      {
        "title": "LLM (Large Language Model)-Assisted JupyterQuiz Formatting",
        "description": "This notebook contains a prompt that can be used with an LLM for easier formatting of quiz questions.",
        "type": "notebook",
        "duration": "15 min",
        "github_url": "https://github.com/act-cms/jupyterquiz-tutorial/blob/main/LLM_assisted_jupyterquiz.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/jupyterquiz-tutorial/blob/main/LLM_assisted_jupyterquiz.ipynb",
        "objectives": [
          "Advanced skill development",
          "Application of concepts from Part 1"
        ]
      }
    ],
    "scientific_objectives": [
      "None"
    ],
    "cyberinfrastructure_objectives": [
      "Use JupyterQuiz to add interactive assessments to notebooks"
    ],
    "scientific_prerequisites": [
      "None"
    ],
    "programming_prerequisites": [
      "Knowledge of variables, lists, and dictionaries in Python"
    ],
    "platforms": [
      "Google Colab",
      "ChemCompute",
      "Local Installation"
    ],
    "recommended_platform": "Google Colab",
    "tags": [
      "python",
      "molecular-dynamics",
      "visualization",
      "quantum-chemistry"
    ],
    "id": "jupyterquiz-tutorial",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "jupyterquiz-tutorial",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/jupyterquiz-tutorial&branch=main&urlpath=lab/tree/jupyterquiz-tutorial/"
  },
  {
    "title": "Ocean Acidification",
    "description": "Data analysis for a multi-week Ocean Acidification Experiment in Analytical Chemistry Laboratory.  This module is designed to support the published laboratory experiment 'Ocean Acidification: Investigation and Presentation of the Effects of Elevated Carbon Dioxide Levels on Seawater Chemistry and Calcareous Organisms' by Jeffrey M. Buth, J. Chem. Educ. 2016, 93, 718–721.",
    "expanded_description": "This lesson can be used to analyze pooled mass, pH, and titration data collected by students in an analytical chemistry laboratory.\nThe suggested context would be to walk through it together in the analytical laboratory after data collection.\nIt would be helpful if students have completed the Statistical Testing module prior to this one.\nAt least an hour at the end of *each* lab period should be allocated to this data analysis module; this includes Week 1, when students\nhave no module but should get a head start on reading, commenting, and modifying code so as not to be rushed in Week 2 and Week 3.\n\nYou can use multiple paragraphs to fully describe the lesson scope\nand learning experience.\n",
    "programming_skill": "None",
    "primary_course": "Analytical Chemistry",
    "also_for": [
      "Environmental Chemistry"
    ],
    "authors": [
      "Dr. Christine Morales"
    ],
    "estimated_time": "2-3 hours",
    "format": "Multi-Part Materials Module",
    "instructor_email": "moralech@mountunion.edu",
    "student_level": "Undergraduate - Second Year",
    "students_piloted": 10,
    "instructor_notes": "This module provides practice to reinforce programming skills introduced in prior modules for students with no prior coding experience.\n\nTeaching tips:\n- If time permits during the first week of lab, discuss all relevant equilibria and common ions, and \n  prompt students to hypothesize what might happen to each measured ion as a result of added CO$_2$.\n- If time permits during the first week of lab, a review of statistical hypothesis testing might be useful.  \n- If time permits during the first week of lab, encourage students to work ahead through the Week 2 and Week 3 code.\n  They can comment code, copy/paste and modify code from Week 2 to using Week 3, and recall how to apply statistical hypothesis testing.\n- Students will need to consolidate measured data into a shared class data spreadsheet during lab, then export CSV files to upload here.\n  Please provide the blank spreadsheet templates for students to use in Week 2 and Week 3, and keep an eye out for possible data entry errors.\n- In Week 2, students will need to record the masses of their dry Gooch funnels before beginning the filtering process (see below).\n- In Week 3, students will re-weigh their seashells. Please remind students to subtract the masses of their dry Gooch filters before \n  entering their final seashell-only masses for comparison to their initial seashell masses.\n- It may be possible for seashell masses to slightly *increase* at moderate pH, if magnesium in the seawater combines with carbonate ions.\n- Ideally the students should have previously completed the Statistical Testing module, but if not, they may require detailed instructions\n  as to how to properly rename, upload, and import CSV files.  \n- Students should work together in groups to ensure they are accountable to understand each part.  This is especially important for hypothesis testing.\n- Encourage students to share ideas but code/answer questions in their own copy of the notebook.\n- Remind students to save their own copy before they begin work.\n- Some students may have several Google accounts; remind them to be aware of which account is logged in when they save.\n\nTiming notes:\n- Week 1 has no module, but that time can and should be used to get a head start on the Week 2 and Week 3 modules.\n- In Week 2:\n  -- Task 1 typically takes students 10-15 minutes.  Students should read carefully to find values needed in the code. (no data needed)\n  -- Task 2 typically takes students 15-20 minutes, depending on their file handling skills.  Data entry errors in class data may surface,\n     requiring everyone to re-download and re-upload the CSV files after correction.  (Ideally, checking first could prevent this.)\n  -- Task 3 typically takes students 5-10 minutes.\n  -- Task 4 typically takes students 10-15 minutes.  Students should read carefully to find values needed in the code. \n  -- Task 5 typically takes students 15-20 minutes.  Students should review statistical hypothesis testing including pooled Student's T tests.\n- In Week 3:\n  -- Task 1 typically takes students 10-15 minutes.  Students should read carefully and check their lab notebook to find values needed in the code. \n  -- Task 2 typically takes students 15-20 minutes, depending on their typing and file handling skills.  Copy/paste/modify coding requires attention to detail.\n     Data entry errors in class data may surface, requiring everyone to re-download and re-upload the CSV files after correction.  \n     (Ideally, reminding students to subtract the initial masses of their Gooch funnels, and checking the class data spreadsheet, could prevent this.)\n  -- Task 3 typically takes students 10-15 minutes, depending on their typing skills.  Copy/paste/modify coding requires attention to detail.\n  -- Task 4 typically takes students 15-20 minutes, depending on their typing skills.  Copy/paste/modify coding requires attention to detail.\n  -- Task 5 typically takes students 15-20 minutes, depending on their typing skills.  Copy/paste/modify coding requires attention to detail.\n\nCommon student questions:\n- Students may ask how to download CSV files, how to rename them, and how to import them into the Jupyter notebook.\n- Students may notice a large variation in class data results.  Often this is normal, but sometimes it is a sign of data entry errors.  \n- Students who have gotten ahead may need to be prompted to re-download, re-upload, re-import, and re-calculate if errors are found in class data.\n- If students need to recalculate anything after the lab period, they may need to be prompted to re-import the class data first.\n- Especially in Week 3, students may see results that do not confirm their hypotheses, and/or may see results that are not statistically significant.\n  This is an opportunity to review statistical uncertainty, statistical significance, and/or possible small deviations from the published protocol.\n",
    "related_modules": [
      "moralech-umu-basic-tasks",
      "statistical-testing-beta",
      "solution-preparation-spectrophotometry",
      "standard-addition-spectrophotometry",
      "calibration-of-glassware",
      "buffer-solutions",
      "hplc-analysis",
      "gc-ms-internal-standard"
    ],
    "public_repo_url": "https://github.com/act-cms/ocean-acidification",
    "materials": [
      {
        "title": "Ocean_Acidification Week 2 Student Version",
        "description": "Generate Python code to analyze pH, carbonate and bicarbonate titration data for bottled, CO$_2$-infused, and air-infused seawater",
        "type": "notebook",
        "duration": "60-90 min",
        "github_url": "https://github.com/act-cms/ocean-acidification/blob/main/Ocean_Acidification_W2_Student_Version.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/ocean-acidification/blob/main/Ocean_Acidification_W2_Student_Version.ipynb",
        "objectives": [
          "Content: Use stoichiometry to calculate the lower limit of detection for an analyte in a titration experiment",
          "Content: Calculate percent differences relative to a control",
          "Content: Use statistical concepts to quantify uncertainty in class data",
          "Content: Apply the Student T test to decide whether CO$_2$ significantly affected the measured quantities",
          "Process: Use Python code to transform data using structures such as arrays and tables",
          "Process: Work in teams to manage and share data",
          "Process: Work in teams to evaluate outcomes of statistical tests"
        ]
      },
      {
        "title": "Ocean_Acidification Week 3 Student Version",
        "description": "Generate Python code to analyze seashell mass changes and calcium and magnesium titration data for CO$_2$-infused and air-infused seawater relative to bottled control",
        "type": "notebook",
        "duration": "60-90 min",
        "github_url": "https://github.com/act-cms/ocean-acidification/blob/main/Ocean_Acidification_W3_Student_Version.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/ocean-acidification/blob/main/Ocean_Acidification_W3_Student_Version.ipynb",
        "objectives": [
          "Content: Use stoichiometry to calculate the lower limit of detection for an analyte in a titration experiment",
          "Content: Calculate percent differences relative to a control",
          "Content: Use statistical concepts to quantify uncertainty in class data",
          "Content: Apply the Student T test to decide whether CO$_2$ significantly affected the measured quantities",
          "Process: Modify Python code to transform data using structures such as arrays and tables",
          "Process: Work in teams to manage and share data",
          "Process: Work in teams to evaluate outcomes of statistical tests"
        ]
      }
    ],
    "scientific_objectives": [
      "Use stoichiometry to calculate the lower limit of detection for an analyte in a titration experiment",
      "Calculate percent differences relative to a control",
      "Use statistical concepts to quantify uncertainty in class data",
      "Work in teams to manage and share data",
      "Work in teams to evaluate outcomes of statistical tests"
    ],
    "cyberinfrastructure_objectives": [
      "Modify Python code to transform data using structures such as arrays and tables"
    ],
    "scientific_prerequisites": [
      "General chemistry",
      "Chemical concepts including pH, molar concentration, and stoichiometry in an aqueous solution",
      "Statistical concepts including mean, standard deviation, Student T test, and confidence interval",
      "Limit of detection"
    ],
    "programming_prerequisites": [
      "File handling skills required to save CSV files from a spreadsheet, rename files, and import CSV files using Pandas"
    ],
    "platforms": [
      "Google Colab",
      "Local Installation",
      "ChemCompute"
    ],
    "recommended_platform": "Google Colab",
    "tags": [
      "python",
      "analytical-chemistry",
      "laboratory",
      "data-analysis"
    ],
    "id": "ocean-acidification",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "ocean-acidification",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/ocean-acidification&branch=main&urlpath=lab/tree/ocean-acidification/"
  },
  {
    "title": "Solution Preparation and Spectrophotometry",
    "description": "Data analysis for a Solution Preparation and Spectrophotometry Experiment in Analytical Chemistry Laboratory.",
    "expanded_description": "This lesson can be used to analyze solution preparation and spectrophotometry data collected by students in an analytical chemistry laboratory.\nThe suggested context would be to walk through it together during the corresponding Analytical Laboratory experiment.\nAbout a half hour to an hour should be allocated in lab to this lesson, after data collection is complete.\n\nYou can use multiple paragraphs to fully describe the lesson scope\nand learning experience.\n",
    "programming_skill": "None",
    "primary_course": "Analytical Chemistry",
    "also_for": [
      "Physical Chemistry",
      "General Chemistry"
    ],
    "authors": [
      "Dr. Christine Morales"
    ],
    "estimated_time": "1 hour or less",
    "format": "Single Notebook",
    "instructor_email": "moralech@mountunion.edu",
    "student_level": "Undergraduate - Second Year",
    "students_piloted": 10,
    "instructor_notes": "This introductory module works well as an early (second or third) programming lesson for students with no prior coding experience.\n\nTeaching tips:\n- If your students have already done Basic Tasks and you have time, consider providing less sample code for data entry in Task 1.  \n- If you do not provide sample code for data entry in Task 1, consider prompting students to copy Numpy array data entry syntax from Basic Tasks.\n- If your students took more than one replicate absorbance measurement of each stock concentration (k > 2 in Task 4), \n  the commented-out sample code in the student version of the notebook is a very simple way to just allow them to enter all their data.\n  Error bars displayed in Task 3 will be overestimated in this simple approach, as they will only include data from one replicate.  \n  A more advanced approach is possible: students could enter all values into the same array, and also enter the stock concentrations\n  multiple times into the corresponding array. Students would then need to type in their own value of N rather than rely on a length function.\n- Instructors may choose to point out the vast features of SciPy, which also will be used in more advanced calculations in other modules.\n- It is possible to expand Task 3 if you want to use this as a deeper tutorial on graphing with Matplotlib.\n- Students should work together in groups to ensure they are accountable to understand each part.\n- Encourage students to share ideas but code/answer questions in their own copy of the notebook.\n- Remind students to save their own copy before they begin work.\n- Some students may have several Google accounts; remind them to be aware of which account is logged in when they save.\n\nTiming notes:\n- Task 1 typically takes students 10-15 minutes when sample code is provided.  Add 5 minutes if prompting students to copy Numpy syntax from Basic Tasks.\n- Task 2 typically takes students 5-10 minutes.\n- Task 3 typically takes students 10-15 minutes.   Remind students how to save and print the graph to tape into their lab notebook.\n- Task 4 typically takes students 5-10 minutes.  \n\nCommon student questions:\n- Students may ask how to enter multiple replicate measurements.  Consider making a plan for this before the start of lab.\n- Students may ask if they need to tape the graph into their laboratory notebook before turning it in\n",
    "related_modules": [
      "moralech-umu-basic-tasks",
      "statistical-testing-beta",
      "calibration-of-glassware",
      "standard-addition-spectophotometry",
      "ocean-acidification",
      "buffer-solutions",
      "hplc-analysis",
      "gc-ms-internal-standard"
    ],
    "public_repo_url": "https://github.com/act-cms/solution-preparation-spectrophotometry",
    "materials": [
      {
        "title": "Solution Preparation and Spectrophotometry",
        "description": "This notebook can be used to generate code in Python to perform four tasks: Input dependent and independent variables into arrays; Use SciPy to fit data to a linear model with uncertainty; Use Matplotlib to generate a calibration curve; Use a linear best-fit model with uncertainty to find concentration and propagated uncertainty.",
        "type": "notebook",
        "duration": "1 hour or less",
        "github_url": "https://github.com/act-cms/solution-preparation-spectrophotometry/blob/main/Solution_Preparation_Student_Version.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/solution-preparation-spectrophotometry/blob/main/colab-notebooks/Solution_Preparation_Student_Version.ipynb",
        "objectives": [
          "Content: Explain calibration and analysis for spectrophotometric data",
          "Content: Use a calibration curve to find the concentration of an analyte in solution",
          "Process: Use Python code to transform data using structures such as arrays",
          "Process: Use Python code to visualize data using different types of graphs"
        ]
      }
    ],
    "scientific_objectives": [
      "Explain calibration and analysis for spectrophotometric data",
      "Use a calibration curve to find the concentration of an analyte in solution"
    ],
    "cyberinfrastructure_objectives": [
      "Use Python code to transform data using structures such as arrays",
      "Use Python code to visualize data using different types of graphs"
    ],
    "scientific_prerequisites": [
      "General Chemistry",
      "Familiarity with data sets that can be fit to a *model*, such as a linear calibration curve"
    ],
    "programming_prerequisites": [
      "Familiarity with *arrays*"
    ],
    "platforms": [
      "Google Colab",
      "Local Installation",
      "ChemCompute"
    ],
    "recommended_platform": "Google Colab",
    "tags": [
      "python",
      "analytical-chemistry",
      "laboratory",
      "data-analysis"
    ],
    "id": "solution-preparation-spectrophotometry",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "solution-preparation-spectrophotometry",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/solution-preparation-spectrophotometry&branch=main&urlpath=lab/tree/solution-preparation-spectrophotometry/"
  },
  {
    "title": "Standard Addition Spectrophotometry",
    "description": "Data analysis for a Standard Addition Spectrophotometry Experiment in Analytical Chemistry Laboratory.",
    "expanded_description": "This lesson can be used to analyze standard addition spectrophotometric data collected by students in an analytical chemistry laboratory.\nThe suggested context would be to walk through it together in the analytical laboratory after data collection.\nIt would be helpful if students have completed the Basic Tasks and Solution Preparation modules prior to this one.\nAbout an hour at the end of lab should be allocated to this data analysis module.\n",
    "programming_skill": "None",
    "primary_course": "Analytical Chemistry",
    "also_for": [
      "General Chemistry",
      "Physical Chemistry"
    ],
    "authors": [
      "Dr. Christine Morales"
    ],
    "estimated_time": "1 hour",
    "format": "Single Notebook",
    "instructor_email": "moralech@mountunion.edu",
    "student_level": "Undergraduate - Second Year",
    "students_piloted": 10,
    "instructor_notes": "This module provides practice to reinforce programming skills introduced in two prior modules for students with no prior coding experience.\n\nTeaching tips:\n- If students have not yet been introduced to standard addition methods, consider offering a short explanation of this approach.\n- If you have run a blank with no analytical reagent, remind students to enter *corrected* absorbances (after subtraction) in Task 1.\n- If your students have already done Basic Tasks and you have time, consider providing less sample code for data entry in Task 1.\n- If students have *not* completed the Basic Tasks and Solution Preparation modules prior to this one, consider providing sample code in Task 2.\n- Important: Standard addition methods run a higher risk of exceeding the range of linearity. If plots in Task 2 level off dramatically, \n  ask students to consider going back to Task 1, truncating their arrays accordingly, and recalculating.  This will reduce N, but may improve accuracy.\n- Students should work together in groups to ensure they are accountable to understand each part.\n- Encourage students to share ideas but code/answer questions in their own copy of the notebook.\n- Remind students to save their own copy before they begin work.\n- Some students may have several Google accounts; remind them to be aware of which account is logged in when they save.\n\nTiming notes:\n- Task 1 typically takes students 10-15 minutes when sample code is provided.  Add 5 minutes if prompting students to copy Numpy syntax from Basic Tasks.\n- Task 2 typically takes students 10-15 minutes when sample code is *not* provided.  Subtract 5 minutes if sample code is provided.  \n- Task 3 typically takes students 10-15 minutes.  Remind students to save and print the graph to tape into their lab notebook.\n  *If possible, walk around during Task 2 to check for linearity in student graphs; advise students to truncate data if necessary.*  \n  If necessary, truncating data and then re-running the code cells in Tasks 1, 2 and 3 may take an additional 10-15 minutes.\n- Task 4 typically takes students 5-10 minutes.  This step *cannot* be skipped, even if time is tight.\n\nCommon student questions:\n- Students may ask if they should enter raw absorbance data or corrected absorbance values.\n- Students may ask if they need to tape the graph into their laboratory notebook before turning it in.\n- Students may skip some steps if they find it is necessary to truncate arrays in Part 1 and recalculate.\n  This is a good opportunity to teach/remind students to re-run all code cells in order when recalculating.\n",
    "related_modules": [
      "moralech-umu-basic-tasks",
      "statistical-testing-beta",
      "solution-preparation-spectrophotometry",
      "calibration-of-glassware",
      "ocean-acidification",
      "buffer-solutions",
      "hplc-analysis",
      "gc-ms-internal-standard"
    ],
    "public_repo_url": "https://github.com/act-cms/standard-addition-spectrophotometry",
    "materials": [
      {
        "title": "Standard Addition Spectrophotometry",
        "description": "Generate code in Python to perform four tasks: Entering and processing data as an array; Linear least-squares fitting; Plotting data and a model with uncertainty; Calculating analyte concentration and uncertainty from multiple standard additions.",
        "type": "notebook",
        "duration": "1 hour",
        "github_url": "https://github.com/act-cms/standard-addition-spectrophotometry/blob/main/Standard_Addition_Student_Version.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/standard-addition-spectrophotometry/blob/main/Standard_Addition_Student_Version.ipynb",
        "objectives": [
          "Content: Explain how standard addition permits quantitative analysis of a component in a matrix that could otherwise interfere with the analyte signal.",
          "Content: Use a standard addition calibration curve to find the concentration of an analyte.",
          "Process: Use Python code to transform data using structures such as arrays.",
          "Process: Use Python code to visualize data using different types of graphs."
        ]
      }
    ],
    "scientific_objectives": [
      "Explain how standard addition permits quantitative analysis of a component in a matrix that could otherwise interfere with the analyte signal",
      "Use a standard addition calibration curve to find the concentration of an analyte"
    ],
    "cyberinfrastructure_objectives": [
      "Use Python code to transform data using structures such as arrays",
      "Use Python code to visualize data using different types of graphs"
    ],
    "scientific_prerequisites": [
      "General chemistry",
      "Calibration curves"
    ],
    "programming_prerequisites": [
      "No prior programming experience required"
    ],
    "platforms": [
      "Google Colab",
      "Local Installation",
      "ChemCompute"
    ],
    "recommended_platform": "Google Colab",
    "tags": [
      "python",
      "analytical-chemistry",
      "laboratory",
      "data-analysis"
    ],
    "id": "standard-addition-spectrophotometry",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "standard-addition-spectrophotometry",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/standard-addition-spectrophotometry&branch=main&urlpath=lab/tree/standard-addition-spectrophotometry/"
  },
  {
    "title": "Statistical Testing, or How Heavy is that Penny?",
    "description": "Generate code in Python to perform six tasks for statistical analysis: Upload multiple datasets from CSV files; Reorganize and summarize data; Recognize and address outliers; Apply Student's T test; Perform linear least-squares with propagation of uncertainty; Build and plot histograms.",
    "expanded_description": "This lesson can be used as an introduction to Analytical Chemistry Statistical Analysis tasks in Python.\nThe suggested context would be to walk through it together during the third week of Analytical Laboratory.\nAbout two hours should be allocated to this lesson, in the context of a three-hour period in which the first hour is spent counting pennies.\n\nThis lesson was not piloted in Spring 2025 and therefore is still in the beta testing phase.\nInstructors may wish to tailor the lesson to highlight specific content learning objectives for statistical analysis.\n",
    "programming_skill": "None",
    "primary_course": "Foundational Module",
    "also_for": [
      "Statistics",
      "Statistical Mechanics"
    ],
    "authors": [
      "Dr. Christine Morales"
    ],
    "estimated_time": "2 hours",
    "format": "Single Notebook",
    "instructor_email": "moralech@mountunion.edu",
    "student_level": "Undergraduate - Second Year",
    "students_piloted": 0,
    "instructor_notes": "This introductory module should work well as a third programming lesson for students with no prior coding experience.\n\nTeaching tips:\n- Students are learning for the first time here how to import data from CSV files.  \n- Several types of data and coding structures are introduced here for the first time, so introductory text may be worthwhile for students to read.\n- Using an Excel template to organize data into properly formatted CSV files with matching column headers is critical.\n- (Not included) In Task 2, the Python code here does NOT automatically generate tables of data organized by year for students\n  to print out and tape into their lab notebooks.  If you feel this is useful, the two print statements can be modified to do so.\n- In Task 5, students are asked to copy/paste/modify code for a graph of brass penny data to make a graph for zinc penny data.\n  If time is tight, you may wish to provide students with hints and/or the sample-code for the zinc penny graph.\n- Students should work together in groups to ensure they are accountable to understand each part.\n- Encourage students to share ideas but code/answer questions in their own copy of the notebook.\n- Remind students to save their own copy before they begin work.\n- Some students may have several Google accounts; remind them to be aware of which account is logged in when they save.\n- Keeping an eye on the time may be helpful to ensure students are progressing at a reasonable pace.\n\nTiming notes:\n- Although this has not yet been piloted, it was based on a corresponding activity using Excel that typically took 2 hours.\n- Task 1 is anticipated to take students 20-25 minutes (including the work of creating/uploading properly formatted CSV files)\n- Task 2 is anticipated to take students 10-15 minutes.  \n- Task 3 is *anticipated* to take students 10-20 minutes. If outliers are found and decisions are made to clean data, it may take up to 25 minutes.\n- Task 4 is *anticipated* to take students 15-20 minutes if they already know how a Student's T test works.\n  It may be helpful to stop here and add in a 5-minute mini-lecture about Student's T tests, null hypothesis, etc. so everyone is on the same page.\n- Task 5 is anticipated to take students 10-15 minutes.  If time is tight, you may wish to provide hints and/or sample-code to assist, or else skip the second graph.\n  Also, please remind students of how to save and print the graphs to tape into their lab notebook.\n- Task 6 is *anticipated* to take students 15-20 minutes if they do the code commenting and as instructed.  \n  If time is tight, you may wish to advise students to run the code without comments, and work together on answering questions.\n  Also, please remind students to save and print the graphs to tape into their lab notebook.\n\nCommon student questions:\n- Students may ask if they need to tape the graph into their laboratory notebook before turning it in.\n- Students may ask if the output from Part 2 is sufficient for the data tables that they should print out.\n  If you want the output to include all grouped data, you will need to modify the two print statements in Part 2 accordingly.\n",
    "related_modules": [
      "moralech-umu-basic-tasks",
      "calibration-of-glassware",
      "solution-preparation-spectrophotometry",
      "standard-addition-spectophotometry",
      "ocean-acidification",
      "buffer-solutions",
      "hplc-analysis",
      "gc-ms-internal-standard"
    ],
    "public_repo_url": "https://github.com/act-cms/statistical-testing-beta",
    "materials": [
      {
        "title": "Part 1: Introduction",
        "description": "This Jupyter notebook can be used to generate code in Python to perform six tasks for statistical analysis: Upload multiple datasets from CSV files; Reorganize and summarize data; Recognize and address outliers; Apply Student's T test; Perform linear least-squares with propagation of uncertainty; Build and plot histograms ",
        "type": "notebook",
        "duration": "2 hours",
        "github_url": "https://github.com/act-cms/statistical-testing-beta/blob/main/Statistical_Testing_Student_Version.ipynb",
        "colab_url": "https://colab.research.google.com/github/act-cms/statistical-testing-beta/blob/main/Statistical_Testing_Student_Version.ipynb",
        "objectives": [
          "Content: Define and use statistical concepts that model the effects of random error on a data set",
          "Content: Use careful documentation and/or the statistical Grubbs Test to decide when a data point can be discarded",
          "Content: Apply the Student T test to accept or reject a null hypothesis under several different sets of conditions",
          "Process: Use Python code to transform data using structures such as arrays",
          "Process: Use Python code to visualize data using different types of graphs",
          "Process: Work in teams to manage and share data, and document and share causes of outlier data",
          "Process: Work in teams to evaluate outcomes of statistical tests"
        ]
      }
    ],
    "scientific_objectives": [
      "Define and use statistical concepts that model the effects of random error on a data set",
      "Use careful documentation and/or the statistical Grubbs Test to decide when a data point can be discardeds",
      "Apply the Student T test to accept or reject a null hypothesis under several different sets of conditions"
    ],
    "cyberinfrastructure_objectives": [
      "Use Python code to transform data using structures such as arrays",
      "Use Python code to visualize data using different types of graphs",
      "Work in teams to manage and share data, and document and share causes of outlier data",
      "Work in teams to evaluate outcomes of statistical tests"
    ],
    "scientific_prerequisites": [
      "Basic statistical definitions including mean and standard deviation"
    ],
    "programming_prerequisites": [
      "No prior programming experience required"
    ],
    "platforms": [
      "Google Colab",
      "Local Installation",
      "ChemCompute"
    ],
    "recommended_platform": "Google Colab",
    "tags": [
      "python",
      "analytical-chemistry",
      "laboratory",
      "data-analysis"
    ],
    "id": "statistical-testing-beta",
    "instructor_repo": "act-cms/instructor-materials",
    "instructor_repo_path": "statistical-testing-beta",
    "chemcompute_launch": "https://chemcompute.org/jupyterhub_internal/hub/user-redirect/git-pull?repo=https%3A//github.com/act-cms/statistical-testing-beta&branch=main&urlpath=lab/tree/statistical-testing-beta/"
  }
]